import {
  __commonJS
} from "./chunk-UXIASGQL.js";

// ../node_modules/Router/Router.js
var require_Router = __commonJS({
  "../node_modules/Router/Router.js"(exports, module) {
    var Route = class {
      constructor(regex, allow, callback) {
        this.allowedMethods = allow;
        this.callback = callback;
        if (typeof regex === "string") {
          this.regex = RegExp(`^${regex}$`);
        } else if (regex instanceof RegExp) {
          this.regex = regex;
        } else {
          throw new Error("The route must be a regular expression or a string!");
        }
      }
      fire(req, res) {
        const m = req.url.match(this.regex);
        this.callback(req, res, m);
      }
    };
    var Hook = class _Hook extends Route {
      constructor(regex, allow, callback) {
        super(regex, allow, callback);
      }
      /**
       * Processes a return from a hook.
       * @param {Object} r Response.
       * @param {Request} req
       * @param {Response} res
       */
      static processReturn(r, req, res) {
        if (typeof r === "object") {
          let code = r.code || 200;
          let head = r.head || { "Content-Type": "plain/text" };
          let data = r.data;
          let type = typeof data;
          if (type === "undefined") {
            res.writeHead(code, head);
            res.end();
          } else if (type === "object") {
            head["Content-Type"] = "application/json";
            res.writeHead(code, head);
            res.write(JSON.stringify(data));
            res.end();
          } else {
            res.writeHead(code, head);
            res.write(data);
            res.end();
          }
        } else {
          res.end(r);
        }
      }
      /**
       * Fires the hook.
       * @param {Request} req
       * @param {Response} res
       */
      fire(req, res) {
        const m = req.url.match(this.regex);
        const r = this.callback(req, m);
        if (r instanceof Promise) {
          r.then((data) => {
            _Hook.processReturn(data, req, res);
          });
        } else {
          _Hook.processReturn(r, req, res);
        }
      }
    };
    var Router = class {
      constructor() {
        this.__routes = [];
        this.__final = () => {
        };
      }
      /**
       * Called when the router wants to handle an incoming connection.
       * If a route is matched, the callback is fired. As this simple.
       * @param {RegExp} regex
       * @param {Array} optMode Optional
       * @param {Function} callback
       */
      when(regex, optMode, callback) {
        if (typeof callback === "undefined") {
          let route = new Route(regex, [], optMode);
          this.__routes.push(route);
          return this;
        } else {
          let route = new Route(regex, optMode, callback);
          this.__routes.push(route);
          return this;
        }
      }
      /**
       * This will register a new hook.
       * @param {RegExp} regex
       * @param {Array} optMode Optional
       * @param {Function} callback
       */
      hook(regex, optMode, callback) {
        if (typeof callback === "undefined") {
          let route = new Hook(regex, [], optMode);
          this.__routes.push(route);
          return this;
        } else {
          let route = new Hook(regex, optMode, callback);
          this.__routes.push(route);
          return this;
        }
      }
      /**
       * Syntactic sugar for Router.hook(...);
       * @param {RegExp} r
       * @param {Array} o Optional
       * @param {Function} c
       */
      $(r, o, c) {
        this.hook(r, o, c);
      }
      /**
       * This is called if noone of the when routes has been matched.
       * @param {Function} handler
       */
      finally(handler) {
        this.__final = handler;
      }
      /**
       * Sugar for finally.
       * @param {Function} handler
       */
      final(handler) {
        this.finally(handler);
      }
      /**
       * This applies all the registered routes to the incoming request.
       * @param {Request} req
       * @param {Response} res
       */
      listen(req, res) {
        let m = false;
        this.__routes.forEach((r) => {
          if (!m) {
            let test = r.regex.test(req.url);
            let noSize = r.allowedMethods.length === 0;
            if (test && noSize) {
              m = true;
              r.fire(req, res);
            } else if (test && r.allowedMethods.some((m2) => m2 === req.method)) {
              m = true;
              r.fire(req, res);
            }
          }
        });
        if (!m) {
          this.__final(req, res);
        }
      }
    };
    module.exports = new Router();
  }
});
export default require_Router();
//# sourceMappingURL=Router.js.map
